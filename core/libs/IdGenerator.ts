import { assert } from "/core/libs/assert.ts"

/**
 * IdGenerator is a utility class that generates unique id for various purposes.
 *
 * The id generated by this class is a Base-36 string,
 * following the format (without spaces):
 *
 *     TTTT TTTT TRRR
 *
 * where T is a millisecond-precison timestamp, and R is a random value.
 *
 * The timestamp is the number of milliseconds since the Unix epoch.
 * It can go until 5188 A.D. before overflowing.
 *
 * The randomness is 3 characters long, so there are 46656 (â‰ˆ 2^15.509) possible values.
 * It's not enough to guarantee strong uniqueness on it's own, but it's good enough
 * combined with the millisecond level timestamp.
 */
export class IdGenerator {
    /**
     * Maximum representable time is `36**9 - 1`ms since epoch,
     * or `5188-04-22T11:04:28.415Z`.
     */
    private static readonly maxTimestamp = 36 ** 9 - 1

    /**
     * Returns a random integer between 0 and `max` (exclusive).
     * This function uses `crypto.getRandomValues`.
     */
    private static randomInt(max: number) {
        assert(0 < max && max < 256**6, "Maximum value out of bounds")
        const safeMax = Math.floor(256 ** 6 / max) * max
        const randomPool = new Uint8Array(6)

        let randomNum
        do {
            // Rejection sampling to avoid modulo bias.
            crypto.getRandomValues(randomPool)
            randomNum = randomPool.reduce((acc, cur) => acc * 256 + cur, 0)
        } while (randomNum >= safeMax)

        return randomNum % max
    }

    private static getR3() {
        const rand = this.randomInt(36 ** 3)
        return rand.toString(36).padStart(3, "0").toUpperCase()
    }

    private static getT9(time: number) {
        assert(0 < time && time < this.maxTimestamp, "Timestamp out of bounds")
        return time.toString(36).padStart(9, "0").toUpperCase()
    }

    /**
     * Generates a new 12-characters long id.
     */
    static generate(time: number = Date.now()) {
        return this.getT9(time) + this.getR3()
    }

    /**
     * Generates a new id, filling the imprecision of the timestamp with randomness.
     */
    static withTimeCompensentation(time: number, precision: TimePrecision) {
        const date = new Date(time)
        const [rh, rm, rs, rms] = [
            this.randomInt(24),
            this.randomInt(60),
            this.randomInt(60),
            this.randomInt(1000),
        ]

        switch (precision) {
            case "d":
                date.setHours(rh, rm, rs, rms)
                break
            case "h":
                date.setMinutes(rm, rs, rms)
                break
            case "m":
                date.setSeconds(rs, rms)
                break
            case "s":
                date.setMilliseconds(rms)
                break
            case "ms":
                break
        }

        return this.generate(date.getTime())
    }

    /**
     * Returns the timestamp of the id.
     */
    static getTime(id: string) {
        return new Date(parseInt(id.slice(0, 9), 36))
    }
}

type TimePrecision = "ms" | "s" | "m" | "h" | "d"
